// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Best_Solve

//@version=5
indicator(title='my Moving Average Support and Resistance Channel', shorttitle='my double MA Channel', format=format.price, precision=8, overlay=true, timeframe='')
mode = input.string(defval='User Defined', title='Mode', options=['Auto', 'User Defined'])
smoothing = input.string(defval='VWMA', title='Smoothing', options=['SMA', 'EMA', 'RMA', 'WMA', 'VWMA', 'HMA'])
length = input.int(200, minval=1, title='Length')
x1 = input.float(5, '大Factor', minval=0.001, maxval=5)
x2 = input.float(3.75, '小Factor', minval=0.001, maxval=5)
HTFp = timeframe.period == '1' ? 60 : timeframe.period == '3' ? 20 : timeframe.period == '5' ? 48 : timeframe.period == '15' ? 96 : timeframe.period == '30' ? 48 : timeframe.period == '45' ? 32 : timeframe.period == '60' ? 24 : timeframe.period == '120' ? 84 : timeframe.period == '180' ? 56 : timeframe.period == '240' ? 42 : timeframe.period == 'D' ? 30 : timeframe.period == 'W' ? 52 : 12

len = mode == 'Auto' ? HTFp : length

ma_function(source, length) =>
    if smoothing == 'SMA'
        ta.sma(source, len)
    else
        if smoothing == 'EMA'
            ta.ema(source, len)
        else
            if smoothing == 'RMA'
                ta.rma(source, len)
            else
                if smoothing == 'WMA'
                    ta.wma(source, len)
                else
                    if smoothing == 'VWMA'
                        ta.vwma(source, len)
                    else
                        ta.hma(source, len)

// 拿到 高点和低点
serie1 = close > open ? close : close < open ? open : high
// 如果是绿线,  就拿到 close,  如果是红线,  就拿到 open,  如果 open == close, 就拿到 高点, 总之, 拿到高点
serie2 = close < open ? close : close > open ? open : low
// 拿到低点

// x表示 1.618 黄金比例 系数

big_bottom = ma_function(serie1, len) - x1 * ma_function(ta.tr(true), len)
big_top = ma_function(serie2, len) + x1 * ma_function(ta.tr(true), len)

big_bottom1 = big_bottom - x1 * ma_function(ta.tr(true), len)
big_top1 = big_top + x1 * ma_function(ta.tr(true), len)


small_bottom = ma_function(serie1, len) - x2 * ma_function(ta.tr(true), len)
small_top = ma_function(serie2, len) + x2 * ma_function(ta.tr(true), len)

small_bottom1 = small_bottom - x2 * ma_function(ta.tr(true), len)
small_top1 = small_top + x2 * ma_function(ta.tr(true), len)

// 中线, 某个 平均值 的 ma
basis = ma_function(hlc3, len)


plot(big_top, '大top0', color=color.new(color.red, 0))
plot(big_bottom, '大bottom0', color=color.new(color.green, 0))
plot(big_top1, '大top1')
plot(big_bottom1, '大bottom1')
plot(basis, 'Middle Line', color=color.new(color.yellow, 0))


plot(small_top, '小top0', color=color.new(color.red, 0))
plot(small_bottom, '小bottom0', color=color.new(color.green, 0))
plot(small_top1, '小top1')
plot(small_bottom1, '小bottom1')
